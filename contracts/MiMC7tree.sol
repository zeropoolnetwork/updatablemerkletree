pragma solidity >=0.5.2;



library MiMC {
  function sponge(uint256 a, uint256 b) external pure returns(uint256);
}



contract MiMC7tree {
  function computeRoot(uint[] memory pi, uint index, uint leaf) public pure returns(uint) {
    uint root = leaf;
    uint pi_len = pi.length;
    for(uint i = 0; i < pi_len; i++) {
      root = ((index >> i) & 1) == 0 ? MiMC.sponge(root, pi[i]) : MiMC.sponge(pi[i], root);
    }
    return root;
  }

  function updateRoot(uint[16] memory pi, uint index, uint[] memory elements) public pure returns(uint) {
    uint[17] memory merkleDefaults = [
      0,
      3089049976446759283073903078838002107081160427222305800976141688008169211302,
      8116338620616129767987338145084268658642153070769129354420409603238406897855,
      8878064537060745634570788330727085145775583656470491877633306875510029095154,
      3828257545379130720755761895954073265133996959854246541382508304072554854392,
      17068073997582159217216767529457142652777286163239352953564913751936105477380,
      3257671161004122868460398774651042478082454866882959184273871463027584541930,
      20273047627275892647822525415934186324604911513241649272487694702425859791541,
      15435475437088032890607727185787186711529771838568784473330669295776279048178,
      3458096956558303540199804484308193318099731139024197346082793483171297354517,
      16125569309506353884584101408694438898021850546041494841296104247448644318397,
      14107359434792879602934242187506728872889636395556478312324803833255724965038,
      10206719365326097551205820658588465600745372910179126731845823270516953041987,
      1213954298863408481866486814461691132129546587228616670713891467289798767932,
      18436386756031873610861394144246614301091681621345754220192462692611305838034,
      12856947908159875768498566691661460075601589928706840039549293316841743946159,
      11208300819560171976854369439142163132601103910445974060238362602696769827980 ];

    uint elements_len = elements.length;
    require((index+elements_len)<=(1<<16));
    uint offset = index & 0x1;
    uint memframe_len = elements_len + offset;
    uint[] memory memframe = new uint[](memframe_len+1);

    for (uint i=0; i<elements_len; i++)
      memframe[i+offset] = elements[i];
    if (offset > 0)
      memframe[0] = pi[0];
    for (uint i = 1; i < 17; i++) {
      offset = (index >> i) & 0x1;
      for(uint j = 0; j<((memframe_len+1) >> 1); j++) {
        memframe[j+offset] = MiMC.sponge(memframe[j*2], memframe[j*2+1]);
      }
      memframe_len = offset + ((memframe_len+1) >> 1);
      if (memframe_len&0x1 == 1)
        memframe[memframe_len] = merkleDefaults[i];
      if (offset > 0)
        memframe[0] = pi[i];
    }
    return memframe[0];
  }
}

